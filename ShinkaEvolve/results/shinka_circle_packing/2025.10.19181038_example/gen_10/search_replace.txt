<NAME>
triple_layer_angular_offset_and_staggered_ring
</NAME>

<DESCRIPTION>
The current code uses two concentric rings (6 and 12 circles) plus edge and corner placements, but the spacing between circles in the outer ring is not optimal due to uniform spacing and overlap with edge/corner circles. By (1) introducing a third ring with 8 circles (so: 6, 8, 12), (2) staggering angular offsets to avoid "radial alignment" between rings, and (3) nudging edge and corner circles further inwards, we can alleviate overlap and allow slightly larger radii, especially at the transition between rings and square edge. The number of circles is adjusted: center (1), first ring (6), second ring (8), third ring (8), edge-centers (2), corners (1) = 1+6+8+8+2+1 = 26. I also increase the number of repulsion iterations and decrease the repulsion threshold to further reduce overlaps. This hybrid, staggered multi-ring approach is inspired by densest known packings for moderate n and should increase the sum of radii.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Layer assignment:
    # 0: Center
    # 1-6: Inner hexagon ring (6)
    # 7-18: Outer dodecagon ring (12)
    # 19-22: Edge-centers (4)
    # 23-26: Corners (4)

    # --- Central circle ---
    centers[0] = [0.5, 0.5]

    # --- Inner ring (hexagon, radius r1) ---
    # r1 = 0.23 ensures separation from center and outer
    r1 = 0.23
    for i in range(6):
        angle = 2*np.pi*i/6
        centers[1+i] = [0.5 + r1*np.cos(angle), 0.5 + r1*np.sin(angle)]

    # --- Outer ring (dodecagon, radius r2) ---
    r2 = 0.42
    outer_angle_offset = np.pi/12  # slight rotation for better edge coverage
    for i in range(12):
        angle = 2*np.pi*i/12 + outer_angle_offset
        centers[7+i] = [0.5 + r2*np.cos(angle), 0.5 + r2*np.sin(angle)]

    # --- Edge-centers (inset slightly to allow larger radii) ---
    edge_inset = 0.062
    centers[19] = [0.5, edge_inset]
    centers[20] = [1-edge_inset, 0.5]
    centers[21] = [0.5, 1-edge_inset]
    centers[22] = [edge_inset, 0.5]

    # --- Corners (inset for larger radii) ---
    corner_inset = 0.061
    centers[23] = [corner_inset, corner_inset]
    centers[24] = [1-corner_inset, corner_inset]
    centers[25] = [1-corner_inset, 1-corner_inset]
    centers[26-1] = [corner_inset, 1-corner_inset]
=======
    # Layer assignment:
    # 0: Center
    # 1-6: First ring (hexagon, 6)
    # 7-14: Second ring (octagon, 8)
    # 15-22: Third ring (octagon, 8)
    # 23-24: Edge centers (2)
    # 25: One corner (1)  (remaining corners omitted for less crowding)

    # --- Central circle ---
    centers[0] = [0.5, 0.5]

    # --- First ring (hexagon, radius r1) ---
    r1 = 0.185
    for i in range(6):
        angle = 2*np.pi*i/6 + np.pi/12
        centers[1+i] = [0.5 + r1*np.cos(angle), 0.5 + r1*np.sin(angle)]

    # --- Second ring (octagon, radius r2, angular offset) ---
    r2 = 0.295
    for i in range(8):
        angle = 2*np.pi*i/8
        centers[7+i] = [0.5 + r2*np.cos(angle), 0.5 + r2*np.sin(angle)]

    # --- Third ring (octagon, radius r3, staggered offset) ---
    r3 = 0.41
    angle_offset3 = np.pi/8
    for i in range(8):
        angle = 2*np.pi*i/8 + angle_offset3
        centers[15+i] = [0.5 + r3*np.cos(angle), 0.5 + r3*np.sin(angle)]

    # --- Edge-centers (inset for larger radii) ---
    edge_inset = 0.08
    centers[23] = [0.5, edge_inset]
    centers[24] = [0.5, 1-edge_inset]

    # --- Single corner (most favorable) ---
    corner_inset = 0.07
    centers[25] = [corner_inset, corner_inset]
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH
    # --- Local repulsion refinement (mini-optimization) ---
    # Only nudge outer, edge, and corner circles, not the center or inner ring (structural backbone)
    movable = np.array([False]*7 + [True]*12 + [True]*4 + [True]*4)
    repulse_iters = 8
    repulse_eps = 1e-3
    for _ in range(repulse_iters):
        for i in range(n):
            if not movable[i]:
                continue
            dxy = np.zeros(2)
            for j in range(n):
                if i == j:
                    continue
                delta = centers[i] - centers[j]
                dist = np.linalg.norm(delta)
                if dist < 1e-8:
                    dxy += np.random.randn(2)*1e-3
                elif dist < 0.07:
                    # Strong repulsion for near-coincident
                    dxy += delta / (dist+1e-6) * 0.013
                elif dist < 0.18:
                    # Moderate repulsion
                    dxy += delta / dist * 0.004
            # Bias to stay in the square
            for d in range(2):
                if centers[i][d] < 0.015:
                    dxy[d] += 0.01
                if centers[i][d] > 0.985:
                    dxy[d] -= 0.01
            centers[i] += dxy
        # Clamp to square (with inset)
        centers = np.clip(centers, 0.013, 0.987)
=======
    # --- Local repulsion refinement (mini-optimization) ---
    # Only nudge outer two rings, edge, and corner circles, not the center or first ring (structural backbone)
    movable = np.array([False]*7 + [True]*8 + [True]*8 + [True]*2 + [True])
    repulse_iters = 18
    repulse_eps = 1e-3
    for _ in range(repulse_iters):
        for i in range(n):
            if not movable[i]:
                continue
            dxy = np.zeros(2)
            for j in range(n):
                if i == j:
                    continue
                delta = centers[i] - centers[j]
                dist = np.linalg.norm(delta)
                if dist < 1e-8:
                    dxy += np.random.randn(2)*1e-3
                elif dist < 0.06:
                    # Strong repulsion for near-coincident
                    dxy += delta / (dist+1e-6) * 0.016
                elif dist < 0.16:
                    # Moderate repulsion
                    dxy += delta / dist * 0.007
            # Bias to stay in the square
            for d in range(2):
                if centers[i][d] < 0.012:
                    dxy[d] += 0.014
                if centers[i][d] > 0.988:
                    dxy[d] -= 0.014
            centers[i] += dxy
        # Clamp to square (with inset)
        centers = np.clip(centers, 0.012, 0.988)
>>>>>>> REPLACE

</DIFF>