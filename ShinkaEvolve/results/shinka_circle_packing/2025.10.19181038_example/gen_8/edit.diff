--- a/original.py
+++ b/original.py
@@ -1,146 +1,137 @@
 # EVOLVE-BLOCK-START
-"""Layered adaptive grid for improved 26-circle packing in a unit square."""
+"""Hierarchical honeycomb with privileged edge/corner and adaptive repulsion for 26-circle packing."""
 
 import numpy as np
 
 def construct_packing():
     """
-    Construct an arrangement of 26 circles in a unit square
-    maximizing the sum of their radii, using a layered adaptive hybrid grid.
-    
+    Construct an arrangement of 26 circles in a unit square maximizing the sum of radii.
     Returns:
-        Tuple of (centers, radii)
-        centers: np.array of shape (26, 2) with (x, y) coordinates
-        radii: np.array of shape (26) with radius of each circle
+        centers: np.array of shape (26, 2)
+        radii: np.array of shape (26,)
     """
     n = 26
     centers = np.zeros((n, 2))
     idx = 0
 
-    # 1. Place circles at corners and edge centers (8 circles)
-    # Corners
-    corner_eps = 0.015
+    # 1. Place 4 corners and 4 edge centers â€” these will be larger
+    margin = 0.016
+    edge_margin = 0.032
     corners = [
-        [corner_eps, corner_eps],
-        [1 - corner_eps, corner_eps],
-        [1 - corner_eps, 1 - corner_eps],
-        [corner_eps, 1 - corner_eps]
+        [margin, margin],
+        [1 - margin, margin],
+        [1 - margin, 1 - margin],
+        [margin, 1 - margin]
     ]
     for c in corners:
         centers[idx] = c
         idx += 1
-    # Edge centers
-    edge_eps = 0.025
-    edge_centers = [
-        [0.5, edge_eps],
-        [1 - edge_eps, 0.5],
-        [0.5, 1 - edge_eps],
-        [edge_eps, 0.5]
+    edges = [
+        [0.5, edge_margin],
+        [1 - edge_margin, 0.5],
+        [0.5, 1 - edge_margin],
+        [edge_margin, 0.5]
     ]
-    for c in edge_centers:
+    for c in edges:
         centers[idx] = c
         idx += 1
 
-    # 2. Central 3x3 adaptive grid (9 circles)
-    grid_N = 3
-    grid_start = 0.32
-    grid_stop = 0.68
-    grid_pts = np.linspace(grid_start, grid_stop, grid_N)
-    center_grid = []
-    for i in range(grid_N):
-        for j in range(grid_N):
-            # Slightly jitter grid points to break symmetry and allow better radii
-            jitter = 0.012 * np.array([np.random.uniform(-1,1), np.random.uniform(-1,1)])
-            pt = [grid_pts[i], grid_pts[j]]
-            pt_jit = np.clip(np.array(pt) + jitter, 0.1, 0.9)
-            center_grid.append(pt_jit)
-    # Place these 9
-    for pt in center_grid:
+    # 2. Place a central circle
+    centers[idx] = [0.5, 0.5]
+    idx += 1
+
+    # 3. Build a 3x3 honeycomb grid (hex pattern) for the interior
+    # Honeycomb cell size is chosen to fit 9 circles in the interior
+    honeycomb_scale = 0.185  # Controls how far from center each cell goes
+    honeycomb_pts = []
+    for i in range(-1, 2):
+        for j in range(-1, 2):
+            # Offset alternate rows
+            x = 0.5 + honeycomb_scale * (i + 0.5 * (j % 2))
+            y = 0.5 + honeycomb_scale * np.sqrt(3)/2 * j
+            # Ensure not coincident with center
+            if abs(i) + abs(j) == 0:
+                continue
+            honeycomb_pts.append([x, y])
+    for pt in honeycomb_pts:
         centers[idx] = pt
         idx += 1
 
-    # 3. Adaptive non-uniform outer ring (9 circles)
-    # Distribute with variable radius and angle to avoid edge/corner crowding
-    ring_radii = np.linspace(0.38, 0.46, 9)  # Variable radius for slight spreading
-    ring_angles = np.linspace(0, 2 * np.pi, 9, endpoint=False)
-    for i in range(9):
-        r = ring_radii[i]
-        angle = ring_angles[i] + 0.13 * np.sin(i)
-        # Squeeze away from corners by a factor depending on angle
-        x = 0.5 + r * np.cos(angle)
-        y = 0.5 + r * np.sin(angle)
-        # Perturb slightly to break symmetry
-        x += 0.02 * np.sin(2*angle)
-        y += 0.02 * np.cos(3*angle)
-        x = np.clip(x, 0.09, 0.91)
-        y = np.clip(y, 0.09, 0.91)
+    # 4. Place remaining circles in an adaptive outer ring (9 circles)
+    # The radius is chosen so circles are not too close to edges/corners, and are repelled if so
+    num_outer = 9
+    ring_r = 0.38
+    ring_theta = np.linspace(0, 2*np.pi, num_outer, endpoint=False)
+    for ii in range(num_outer):
+        theta = ring_theta[ii]
+        # Initial
+        x = 0.5 + ring_r * np.cos(theta)
+        y = 0.5 + ring_r * np.sin(theta)
+        # Adaptive: repel from corners and edge-centers
+        repulse = np.zeros(2)
+        for c in corners + edges:
+            vec = np.array([x, y]) - np.array(c)
+            dist = np.linalg.norm(vec)
+            if dist < 0.22:
+                repulse += (vec / (dist + 1e-10)) * (0.018 / (dist + 0.018))
+        x += repulse[0]
+        y += repulse[1]
+        # Slight jitter to break symmetry and avoid local minima
+        x += 0.009 * np.sin(ii + 0.3)
+        y += 0.009 * np.cos(ii + 0.6)
+        x = np.clip(x, 0.08, 0.92)
+        y = np.clip(y, 0.08, 0.92)
         centers[idx] = [x, y]
         idx += 1
 
     assert idx == n
 
-    # Compute maximum valid radii for this configuration
-    radii = compute_max_radii_greedy(centers)
+    # 5. Local repulsion: push interior honeycomb points out if too close to corners/edges
+    interior_idx = list(range(8, 17))
+    special_idx = list(range(0,8))
+    for k in interior_idx:
+        for j in special_idx:
+            d = np.linalg.norm(centers[k] - centers[j])
+            if d < 0.21:
+                # Push away
+                push_vec = (centers[k] - centers[j])
+                if np.linalg.norm(push_vec) > 0:
+                    push_vec = push_vec / np.linalg.norm(push_vec)
+                    centers[k] += 0.012 * push_vec
+
+    # 6. Iterative max-min radii update
+    radii = maximize_radii_iterative(centers, passes=5)
     return centers, radii
 
-
-def compute_max_radii_greedy(centers, passes=3):
+def maximize_radii_iterative(centers, passes=5):
     """
-    Compute the maximum possible radii for each circle position
-    using a greedy pass with repeated overlap resolution.
-
-    Args:
-        centers: np.array of shape (n, 2) with (x, y) coordinates
-        passes: how many times to sweep through all pairs to resolve conflicts
-
-    Returns:
-        np.array of shape (n) with radius of each circle
+    Iteratively maximize each circle's radius given others' positions and radii.
+    Each pass, maximize for each circle in turn.
     """
     n = centers.shape[0]
     radii = np.ones(n)
-
-    # Initial: limit by distance to borders
+    # Initial: border-limited
     for i in range(n):
         x, y = centers[i]
         radii[i] = min(x, y, 1 - x, 1 - y)
-
-    # Iteratively resolve pairwise overlaps (greedy, a few passes)
     for _ in range(passes):
         for i in range(n):
-            for j in range(i + 1, n):
+            # For each other circle, the distance minus its radius is a limit
+            min_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])
+            for j in range(n):
+                if i == j: continue
                 d = np.linalg.norm(centers[i] - centers[j])
-                if radii[i] + radii[j] > d:
-                    # Shrink both proportionally so sum = d
-                    if d > 1e-12:
-                        scale = d / (radii[i] + radii[j])
-                        radii[i] *= scale
-                        radii[j] *= scale
-                    else:
-                        # Coincident centers: set both radii to zero
-                        radii[i] = 0
-                        radii[j] = 0
-
-    # Final: local radius boost (try to maximize each circle individually)
-    for i in range(n):
-        # Find min distance to border
-        x, y = centers[i]
-        border = min(x, y, 1 - x, 1 - y)
-        # Find min distance to any other center minus that circle's radius
-        min_dist = border
-        for j in range(n):
-            if i == j: continue
-            d = np.linalg.norm(centers[i] - centers[j]) - radii[j]
-            min_dist = min(min_dist, d)
-        radii[i] = max(0, min_dist)
+                min_r = min(min_r, d - radii[j])
+            radii[i] = max(min_r, 0)
     return radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii