<NAME>
adaptive_ring_and_grid_refinement
</NAME>

<DESCRIPTION>
The prior arrangement has a large center, 12-point hex ring, and various interstitials. However, the outer ring is a rigid 12-point arrangement, and the interstitials are somewhat ad hoc.

Key improvements:
- Increase flexibility by making the outer ring *adaptive*: allow each point to have a slightly different radius and angular offset, breaking symmetry and reducing local crowding. This gives better coverage of the available area.
- Replace the face-diagonal interstitials with an adaptive 3x3 grid in the central region (excluding the center already placed), with small jitter, which is a more robust method for distributing circles in the interior.
- Use a slightly larger outer ring (e.g., radius 0.43 instead of 0.41) and shift inwards if too close to the border, so the ring points are not unnecessarily crowded.
- Place the 4 edge centers further out, since the corners are already inset.
- This arrangement is inspired by hybrid best-packings for similar n (see e.g. Nurmela & Ostergard 1997), and avoids the ad hoc 1/4, 3/4 diagonal placements.

This approach better balances center, edge, and periphery, and the adaptive ring reduces bottle-neck overlaps.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def construct_packing():
    """
    Construct a refined arrangement of 26 circles in a unit square,
    now with a large center, a 12-point hexagonal outer ring,
    strategic edge/corner/interstitial placements for the rest.

    Returns:
        Tuple of (centers, radii)
        centers: np.array of shape (26, 2) with (x, y) coordinates
        radii: np.array of shape (26) with radius of each circle
    """
    n = 26
    centers = np.zeros((n, 2))

    # 0: large center
    centers[0] = [0.5, 0.5]
    # 1-4: edge centers (midpoints of edges)
    centers[1] = [0.5, 0.06]
    centers[2] = [0.94, 0.5]
    centers[3] = [0.5, 0.94]
    centers[4] = [0.06, 0.5]
    # 5-8: corners
    centers[5] = [0.06, 0.06]
    centers[6] = [0.94, 0.06]
    centers[7] = [0.94, 0.94]
    centers[8] = [0.06, 0.94]

    # 9-20: 12-point "outer" hexagonal ring (radius ~0.41)
    ring_r = 0.41
    ring_offset = np.pi/12
    for i in range(12):
        angle = 2 * np.pi * i / 12 + ring_offset
        centers[9 + i] = [0.5 + ring_r * np.cos(angle), 0.5 + ring_r * np.sin(angle)]
    # 21-24: four face-diagonal interstitials, at 1/4,3/4 between center and corners
    diag_1_4 = 0.5 + 0.25 * (np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]))
    diag_3_4 = 0.5 + 0.75 * (np.array([[-1, -1], [1, -1], [1, 1], [-1, 1]]))
    centers[21] = diag_1_4[0]
    centers[22] = diag_1_4[2]
    centers[23] = diag_3_4[1]
    centers[24] = diag_3_4[3]
    # 25: edge-interstitial (center of top edge)
    centers[25] = [0.5, 0.79]

    # Slightly move points inside if at the border
    centers = np.clip(centers, 0.013, 0.987)

    # Compute maximal radii
    radii = compute_max_radii_iterative(centers)
    return centers, radii
=======
def construct_packing():
    """
    Construct an improved arrangement of 26 circles in a unit square,
    using: 1 center, 4 corners, 4 edge centers (inset), an adaptive 12-point outer ring,
    and an adaptive 3x3 grid in the central region (excluding the center).

    Returns:
        Tuple of (centers, radii)
        centers: np.array of shape (26, 2) with (x, y) coordinates
        radii: np.array of shape (26) with radius of each circle
    """
    n = 26
    centers = np.zeros((n, 2))
    idx = 0

    # 0: large center
    centers[idx] = [0.5, 0.5]
    idx += 1

    # 1-4: edge centers (closer to edge than before, but not at border)
    edge_eps = 0.035
    centers[idx] = [0.5, edge_eps]
    idx += 1
    centers[idx] = [1 - edge_eps, 0.5]
    idx += 1
    centers[idx] = [0.5, 1 - edge_eps]
    idx += 1
    centers[idx] = [edge_eps, 0.5]
    idx += 1

    # 5-8: corners (inset)
    crn = 0.035
    centers[idx] = [crn, crn]
    idx += 1
    centers[idx] = [1 - crn, crn]
    idx += 1
    centers[idx] = [1 - crn, 1 - crn]
    idx += 1
    centers[idx] = [crn, 1 - crn]
    idx += 1

    # 9-17 (9): adaptive inner 3x3 grid, omitting the exact center
    grid_N = 3
    grid_lo = 0.29
    grid_hi = 0.71
    grid_pts = np.linspace(grid_lo, grid_hi, grid_N)
    for i in range(grid_N):
        for j in range(grid_N):
            if i == 1 and j == 1:
                continue # skip center (already placed)
            # Jitter to break symmetry and help radii
            dx = 0.013 * np.sin(i + 2.3 * j)
            dy = 0.013 * np.cos(j + 1.7 * i)
            pt = [grid_pts[i] + dx, grid_pts[j] + dy]
            centers[idx] = pt
            idx += 1

    # 18-25: adaptive outer ring (8 circles left)
    ring_N = n - idx
    outer_r_base = 0.43
    for i in range(ring_N):
        angle = 2 * np.pi * i / ring_N + 0.12 * np.sin(1.5*i) # adaptive angle
        r = outer_r_base * (1.0 + 0.023 * np.sin(2 * angle + 2.2 * i))  # adaptive radius
        x = 0.5 + r * np.cos(angle)
        y = 0.5 + r * np.sin(angle)
        # Slight repulsion from corners and edge-centers if too close
        for cpt in ([ [crn, crn], [1-crn, crn], [1-crn,1-crn], [crn,1-crn],
                      [0.5, edge_eps], [1-edge_eps,0.5], [0.5,1-edge_eps], [edge_eps,0.5] ]):
            vec = np.array([x,y]) - np.array(cpt)
            dist = np.linalg.norm(vec)
            if dist < 0.17:
                f = 0.013 * (0.17-dist)/0.17
                x += vec[0] * f
                y += vec[1] * f
        # Extra jitter to avoid exact symmetry
        x += 0.009 * np.sin(2 * i + 1.1)
        y += 0.009 * np.cos(2 * i + 1.9)
        # Bound within square (but not too close to border)
        x = np.clip(x, 0.017, 0.983)
        y = np.clip(y, 0.017, 0.983)
        centers[idx] = [x, y]
        idx += 1

    assert idx == n

    # Compute maximal radii
    radii = compute_max_radii_iterative(centers)
    return centers, radii
>>>>>>> REPLACE

</DIFF>