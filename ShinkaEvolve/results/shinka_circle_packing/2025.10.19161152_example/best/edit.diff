--- a/original.py
+++ b/original.py
@@ -1,150 +1,166 @@
 # EVOLVE-BLOCK-START
-"""Adaptive hexagonal/edge-relaxed circle packing for n=26 circles"""
+"""Genetic + CMA-ES evolutionary circle packing for n=26 in a unit square."""
 
 import numpy as np
 
 def construct_packing():
     """
-    Construct an arrangement of 26 circles in a unit square
-    that attempts to maximize the sum of their radii using
-    a central hexagonal core, adaptive edge/corner circles,
-    and local repulsion-based relaxation.
+    Use genetic algorithm with CMA-ES local refinement to arrange 26 circles
+    in a unit square, maximizing the sum of radii.
     Returns:
-        centers: np.array (26,2) of (x,y) circle centers
-        radii:   np.array (26,) of circle radii
+        centers: np.array (26,2)
+        radii: np.array (26,)
     """
     n = 26
-    centers = np.zeros((n, 2))
-    rng = np.random.default_rng(seed=42)  # deterministic
+    popsize = 33
+    generations = 22
+    elite = 7
+    cmaes_iters = 6
 
-    # 1. 7-circle compact hexagonal core (center + 6 around)
-    hex_r = 0.15
-    centers[0] = [0.5, 0.5]
-    for i in range(6):
-        a = np.pi/6 + i * np.pi/3  # rotate to avoid edge alignment
-        centers[1+i] = [0.5 + hex_r * np.cos(a), 0.5 + hex_r * np.sin(a)]
+    rng = np.random.default_rng(seed=20240613)
+    
+    # Helper: generate random arrangement (centered, rings + jitter)
+    def random_candidate():
+        arr = np.zeros((n,2))
+        idx = 0
+        # Center
+        arr[idx] = [0.5,0.5]; idx += 1
+        # Corners
+        for d in [(0.03,0.03),(0.97,0.03),(0.97,0.97),(0.03,0.97)]:
+            arr[idx] = np.clip(np.array(d) + rng.uniform(-0.012,0.012,2), 0.01, 0.99)
+            idx += 1
+        # Edges
+        for d in [(0.5,0.03),(0.97,0.5),(0.5,0.97),(0.03,0.5)]:
+            arr[idx] = np.clip(np.array(d) + rng.uniform(-0.012,0.012,2), 0.01, 0.99)
+            idx += 1
+        # Hex ring 1
+        base_r = 0.205
+        for i in range(8):
+            a = np.pi/8 + 2*np.pi*i/8 + rng.uniform(-0.11,0.11)
+            r = base_r + rng.uniform(-0.015, 0.015)
+            pos = [0.5 + r*np.cos(a), 0.5 + r*np.sin(a)]
+            arr[idx] = np.clip(pos, 0.01, 0.99)
+            idx += 1
+        # Outer ring
+        outer = n-idx
+        outer_r = 0.44
+        for i in range(outer):
+            a = 2*np.pi*i/outer + rng.uniform(-0.12,0.12)
+            r = outer_r + rng.uniform(-0.017,0.017)
+            pos = [0.5+r*np.cos(a),0.5+r*np.sin(a)]
+            arr[idx] = np.clip(pos, 0.01, 0.99)
+            idx += 1
+        assert idx==n
+        return arr
 
-    # 2. 12 "middle ring" circles, relaxed radius, angle offset to avoid core/edges
-    ring_r = 0.33
-    ring_jitter = 0.03
-    for i in range(12):
-        a = (2*np.pi*i)/12 + np.pi/12
-        r = ring_r + rng.uniform(-ring_jitter, ring_jitter)
-        centers[7+i] = [0.5 + r*np.cos(a), 0.5 + r*np.sin(a)]
+    # Helper: flatten/unflatten
+    def flatten(arr):
+        return arr.reshape(-1)
+    def unflatten(vec):
+        return vec.reshape((n,2))
 
-    # 3. 7 edge/corner circles, slightly inset and jittered to break symmetry
-    edge_idx = 19
-    edge_inset = 0.03
-    jitter = 0.015
-    # corners
-    corners = np.array([
-        [edge_inset, edge_inset],
-        [1-edge_inset, edge_inset],
-        [1-edge_inset, 1-edge_inset],
-        [edge_inset, 1-edge_inset],
-    ])
-    for k in range(4):
-        offset = rng.uniform(-jitter, jitter, 2)
-        centers[edge_idx] = np.clip(corners[k] + offset, 0.01, 0.99)
-        edge_idx += 1
-    # edge midpoints
-    mids = np.array([
-        [0.5, edge_inset],
-        [1-edge_inset, 0.5],
-        [0.5, 1-edge_inset],
-    ])
-    for k in range(3):
-        offset = rng.uniform(-jitter, jitter, 2)
-        centers[edge_idx] = np.clip(mids[k] + offset, 0.01, 0.99)
-        edge_idx += 1
+    # Helper: fitness function
+    def fitness(vec):
+        centers = unflatten(vec)
+        radii = calc_max_radii(centers)
+        # Soft penalty for out-of-square
+        if np.any((centers<0.0) | (centers>1.0)):
+            return -1.0
+        return np.sum(radii)
 
-    # 4. Local repulsion & greedy radii maximization
-    centers, radii = local_relax_and_grow(centers, steps=8)
+    # Helper: greedy radii maximization
+    def calc_max_radii(centers):
+        n = centers.shape[0]
+        radii = np.ones(n)
+        # Border limit
+        for i in range(n):
+            x,y = centers[i]
+            radii[i] = min(x, y, 1-x, 1-y)
+        # Pairwise limit
+        for t in range(3):  # multiple passes for fairness
+            for i in range(n):
+                for j in range(i+1,n):
+                    d = np.linalg.norm(centers[i]-centers[j])
+                    if d < 1e-8:
+                        radii[i] *= 0.88
+                        radii[j] *= 0.88
+                        continue
+                    max_ij = d/2.0
+                    if radii[i]>max_ij:
+                        radii[i]=max_ij
+                    if radii[j]>max_ij:
+                        radii[j]=max_ij
+        return radii
 
+    # --- Genetic Algorithm Main Loop ---
+    pop = np.array([flatten(random_candidate()) for _ in range(popsize)])
+    pop_fitness = np.array([fitness(ind) for ind in pop])
+
+    for gen in range(generations):
+        # Elitism: select best
+        elite_idx = np.argsort(-pop_fitness)[:elite]
+        newpop = [pop[i].copy() for i in elite_idx]
+
+        # Variation: crossover + mutation
+        while len(newpop) < popsize:
+            # Tournament selection
+            p1, p2 = rng.choice(popsize, 2, replace=False)
+            if pop_fitness[p1]>pop_fitness[p2]:
+                parent = pop[p1]
+            else:
+                parent = pop[p2]
+            child = parent.copy()
+            # Occasional (blend) crossover with another elite
+            if rng.uniform()<0.45:
+                mate = pop[rng.choice(elite_idx)]
+                alpha = rng.uniform(0.18,0.82)
+                child = alpha*child + (1-alpha)*mate
+            # Mutate: gaussian jitter (decaying with gen)
+            noise = rng.normal(0, 0.045*(1-gen/generations), child.shape)
+            child += noise
+            # Clamp
+            child = np.clip(child, 0.01, 0.99)
+            newpop.append(child)
+        pop = np.array(newpop)
+        # Evaluate
+        pop_fitness = np.array([fitness(ind) for ind in pop])
+        # CMA-ES refinement on best (every 3rd gen)
+        if gen%3==0:
+            best = pop[elite_idx[0]].copy()
+            best_score = pop_fitness[elite_idx[0]]
+            x = best.copy()
+            sigma = 0.09*(1-gen/generations)
+            for it in range(cmaes_iters):
+                mutants = []
+                mutant_scores = []
+                for _ in range(8):
+                    step = rng.normal(0,sigma,x.shape)
+                    trial = np.clip(x+step,0.01,0.99)
+                    score = fitness(trial)
+                    mutants.append(trial)
+                    mutant_scores.append(score)
+                mutant_scores = np.array(mutant_scores)
+                best_idx = np.argmax(mutant_scores)
+                if mutant_scores[best_idx] > best_score:
+                    x = mutants[best_idx]
+                    best_score = mutant_scores[best_idx]
+            pop[elite_idx[0]] = x
+            pop_fitness[elite_idx[0]] = best_score
+
+    # Select best
+    best_idx = np.argmax(pop_fitness)
+    best_vec = pop[best_idx]
+    centers = unflatten(best_vec)
+    radii = calc_max_radii(centers)
     return centers, radii
-
-def local_relax_and_grow(centers, steps=8):
-    """
-    Given circle centers, iteratively relax positions to reduce overlaps and edge collisions,
-    and greedily maximize radii.
-    Returns final (centers, radii)
-    """
-    n = centers.shape[0]
-    radii = np.ones(n) * 0.075  # initialize with small radii
-
-    for step in range(steps):
-        # 1. Compute repulsive forces (from overlaps and boundary)
-        disp = np.zeros_like(centers)
-        for i in range(n):
-            xi, yi = centers[i]
-            # Repel from boundaries if close
-            margin = 0.01
-            force = np.zeros(2)
-            if xi < margin:
-                force[0] += (margin - xi) * 1.8
-            if xi > 1-margin:
-                force[0] -= (xi - (1-margin)) * 1.8
-            if yi < margin:
-                force[1] += (margin - yi) * 1.8
-            if yi > 1-margin:
-                force[1] -= (yi - (1-margin)) * 1.8
-            # Repel from other circles if overlap (using current radii)
-            for j in range(n):
-                if i == j: continue
-                dx, dy = centers[i] - centers[j]
-                dist = np.hypot(dx, dy)
-                if dist < 1e-7:  # avoid divide by zero
-                    force += rng.normal(0, 0.001, 2)
-                    continue
-                minsep = radii[i] + radii[j]
-                if dist < minsep * 0.98:  # allow a little slack
-                    push = ((minsep - dist) / dist) * np.array([dx, dy]) * 0.5
-                    force += push
-            disp[i] = force
-
-        # 2. Move centers by small fraction of displacement
-        centers += np.clip(disp, -0.04, 0.04)
-
-        # 3. Clamp back inside unit square
-        centers = np.clip(centers, 0.01, 0.99)
-
-        # 4. Greedily maximize radii
-        radii = maximize_radii(centers)
-
-    return centers, radii
-
-def maximize_radii(centers):
-    """
-    Given centers, compute maximal radii for each circle that fit in square and do not overlap.
-    """
-    n = centers.shape[0]
-    radii = np.ones(n)
-    # Limit by distance to boundary
-    for i in range(n):
-        x, y = centers[i]
-        radii[i] = min(x, y, 1-x, 1-y)
-    # Limit by distance to neighbors
-    for i in range(n):
-        for j in range(i+1, n):
-            d = np.linalg.norm(centers[i] - centers[j])
-            if d < 1e-7:  # overlap, avoid zero division
-                radii[i] *= 0.9
-                radii[j] *= 0.9
-                continue
-            max_ij = d / 2.0
-            if radii[i] > max_ij:
-                radii[i] = max_ij
-            if radii[j] > max_ij:
-                radii[j] = max_ij
-    return radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii