--- a/original.py
+++ b/original.py
@@ -1,154 +1,181 @@
 # EVOLVE-BLOCK-START
-"""Simulated annealing/adaptive ring circle packing for n=26 circles"""
+"""LP-based iterative maximization circle packing for n=26 circles"""
 
 import numpy as np
+from scipy.optimize import linprog
 
 def construct_packing():
     """
-    Pack 26 circles in a unit square using adaptive ring/corner/edge placement,
-    jittered arrangements, and simulated annealing-style local relaxation.
+    Pack 26 circles in a unit square by iteratively maximizing radii with LP,
+    and updating centers by centroidal relaxation.
+    
     Returns:
         centers: np.array (26,2) of (x,y) circle centers
         radii:   np.array (26,) of circle radii
     """
-    rng = np.random.default_rng(seed=1234)
     n = 26
+    rng = np.random.default_rng(seed=6789)
+
+    # Initial centers: variable-size core/edge/corner hybrid
     centers = np.zeros((n, 2))
-    idx = 0
+    # Center
+    centers[0] = [0.5, 0.5]
+    # 6 surrounding (hexagon)
+    for k in range(6):
+        a = np.pi/6 + k * np.pi/3
+        centers[1+k] = [0.5 + 0.15*np.cos(a), 0.5 + 0.15*np.sin(a)]
+    # 8 mid ring
+    for k in range(8):
+        a = np.pi/8 + k*2*np.pi/8
+        centers[7+k] = [0.5 + 0.29*np.cos(a), 0.5 + 0.29*np.sin(a)]
+    # 8 edge/corner
+    preset = [
+        [0.04, 0.04], [0.96, 0.04], [0.96, 0.96], [0.04, 0.96],
+        [0.5, 0.04], [0.96, 0.5], [0.5, 0.96], [0.04, 0.5]
+    ]
+    for k in range(8):
+        centers[15+k] = np.array(preset[k]) + rng.normal(0, 0.012, 2)
+        centers[15+k] = np.clip(centers[15+k], 0.02, 0.98)
+    # 3 outer (filling sparse regions)
+    for k in range(3):
+        a = np.pi/7 + k*2*np.pi/3
+        centers[23+k] = [0.5 + 0.44*np.cos(a), 0.5 + 0.44*np.sin(a)]
+    centers[26-1] = [0.83, 0.19]  # fill a gap near a corner
+    # Small jitter to break symmetry, except for corners/edge
+    centers[:15] += rng.normal(0, 0.012, (15,2))
+    centers = np.clip(centers, 0.02, 0.98)
 
-    # Step 1: Place central circle
-    centers[idx] = [0.5, 0.5]; idx += 1
+    # Iterative LP radii maximization & centroidal relaxation
+    radii = np.full(n, 0.065)
+    for iter in range(16):
+        # Step 1: Maximize radii via LP
+        radii = maximize_radii_lp(centers)
 
-    # Step 2: Place corners, slightly inset and jittered
-    corner_inset = 0.024
-    for d in [(corner_inset, corner_inset),
-              (1-corner_inset, corner_inset),
-              (1-corner_inset, 1-corner_inset),
-              (corner_inset, 1-corner_inset)]:
-        offset = rng.uniform(-0.009, +0.009, 2)
-        centers[idx] = np.clip(np.array(d) + offset, 0.01, 0.99)
-        idx += 1
+        # Step 2: Move each center towards centroid of available space
+        centers = centroidal_update(centers, radii, steps=2, rng=rng)
 
-    # Step 3: Place edge-mid circles, slightly inset and jittered
-    edge_inset = 0.025
-    for d in [(0.5, edge_inset), (1-edge_inset, 0.5), (0.5, 1-edge_inset), (edge_inset, 0.5)]:
-        offset = rng.uniform(-0.012, +0.012, 2)
-        centers[idx] = np.clip(np.array(d) + offset, 0.01, 0.99)
-        idx += 1
+        # Step 3: Small random jitter to escape local minima
+        if iter < 12:
+            centers += rng.normal(0, 0.004*(1-iter/18), centers.shape)
+            centers = np.clip(centers, 0.015, 0.985)
 
-    # Step 4: Place inner ring (8 circles), angle and radius jittered
-    ring1_count = 8
-    ring1_r_mean = 0.24
-    ring1_r_jitter = 0.024
-    ring1_ang_jitter = 0.11
-    base_ang1 = rng.uniform(0, 2*np.pi)
-    for k in range(ring1_count):
-        theta = (base_ang1 + 2*np.pi*k/ring1_count +
-                 rng.uniform(-ring1_ang_jitter, ring1_ang_jitter))
-        ringr = ring1_r_mean + rng.uniform(-ring1_r_jitter, ring1_r_jitter)
-        pos = np.array([0.5 + ringr*np.cos(theta), 0.5 + ringr*np.sin(theta)])
-        centers[idx] = np.clip(pos, 0.01, 0.99)
-        idx += 1
-
-    # Step 5: Place outer ring (9 circles), angle and radius jittered
-    ring2_count = n - idx
-    ring2_r_mean = 0.465
-    ring2_r_jitter = 0.027
-    ring2_ang_jitter = 0.09
-    base_ang2 = rng.uniform(0, 2*np.pi)
-    for k in range(ring2_count):
-        theta = (base_ang2 + 2*np.pi*k/ring2_count +
-                 rng.uniform(-ring2_ang_jitter, ring2_ang_jitter))
-        ringr = ring2_r_mean + rng.uniform(-ring2_r_jitter, ring2_r_jitter)
-        pos = np.array([0.5 + ringr*np.cos(theta), 0.5 + ringr*np.sin(theta)])
-        centers[idx] = np.clip(pos, 0.01, 0.99)
-        idx += 1
-
-    # Step 6: Simulated annealing-style local relaxation + greedy radii max
-    centers, radii = anneal_relax_and_grow(centers, anneal_steps=15, move_scale=0.07, rng=rng)
+    # Final pass for tightest radii
+    radii = maximize_radii_lp(centers)
     return centers, radii
 
-def anneal_relax_and_grow(centers, anneal_steps=15, move_scale=0.07, rng=None):
+def maximize_radii_lp(centers):
     """
-    Given circle centers, iteratively relax positions to reduce overlaps and edge collisions,
-    and greedily maximize radii. Uses simulated annealing-style adaptive steps.
+    For given centers, maximize sum(r) subject to:
+      - r_i >= 0
+      - r_i + r_j <= ||c_i - c_j||  (no overlap)
+      - r_i <= distance to boundary (within square)
     """
     n = centers.shape[0]
-    if rng is None:
-        rng = np.random.default_rng()
-    radii = np.ones(n) * 0.072  # Initial small radii
+    A_ub = []
+    b_ub = []
+    # Non-overlap: r_i + r_j <= dist(c_i, c_j)
+    for i in range(n):
+        for j in range(i+1, n):
+            d = np.linalg.norm(centers[i] - centers[j])
+            if d < 1e-5:
+                d = 1e-5
+            row = np.zeros(n)
+            row[i] = 1
+            row[j] = 1
+            A_ub.append(row)
+            b_ub.append(d-1e-6)
+    # Boundary: r_i <= min(x, y, 1-x, 1-y)
+    for i in range(n):
+        x, y = centers[i]
+        for bound in [x, y, 1-x, 1-y]:
+            row = np.zeros(n)
+            row[i] = 1
+            A_ub.append(row)
+            b_ub.append(bound-1e-6)
+    A_ub = np.stack(A_ub)
+    b_ub = np.array(b_ub)
+    # r_i >= 0
+    bounds = [(0, None)] * n
+    # Objective: maximize sum(r)
+    c = -np.ones(n)
+    res = linprog(c, A_ub, b_ub, bounds=bounds, method='highs')
+    if res.success:
+        radii = res.x
+        # Clamp just in case
+        radii = np.clip(radii, 0, 0.5)
+    else:
+        # fallback: safe greedy radii
+        radii = greedy_radii(centers)
+    return radii
 
-    for step in range(anneal_steps):
-        disps = np.zeros_like(centers)
-        for i in range(n):
-            xi, yi = centers[i]
-            force = np.zeros(2)
-            # Boundary repulsion
-            margin = 0.017
-            steep = 2.1
-            if xi < margin:
-                force[0] += (margin - xi) * steep
-            if xi > 1-margin:
-                force[0] -= (xi - (1-margin)) * steep
-            if yi < margin:
-                force[1] += (margin - yi) * steep
-            if yi > 1-margin:
-                force[1] -= (yi - (1-margin)) * steep
-            # Circle repulsion
-            for j in range(n):
-                if i == j: continue
-                dx, dy = centers[i] - centers[j]
-                dist = np.hypot(dx, dy)
-                if dist < 1e-8:
-                    force += rng.normal(0, 0.003, 2)
-                    continue
-                minsep = radii[i] + radii[j]
-                slack = 0.985
-                if dist < minsep * slack:
-                    push = ((minsep*slack - dist)/dist) * np.array([dx, dy]) * 0.61
-                    force += push
-            # Add random annealing noise (decays with step)
-            noise_scale = 0.006 * (1 - step / (1.05*anneal_steps))
-            force += rng.normal(0, noise_scale, 2)
-            disps[i] = force
-        # Decaying step size
-        s = move_scale * (0.6 + 0.4*(1 - step/(anneal_steps-1)))
-        centers += np.clip(disps, -s, s)
-        centers = np.clip(centers, 0.012, 0.988)
-        # Greedy radii maximization at every step
-        radii = maximize_radii(centers)
-    return centers, radii
-
-def maximize_radii(centers):
-    """
-    Given centers, compute maximal radii for each circle that fit in square and don't overlap.
-    """
+def greedy_radii(centers):
     n = centers.shape[0]
     radii = np.ones(n)
     for i in range(n):
         x, y = centers[i]
         radii[i] = min(x, y, 1-x, 1-y)
     for i in range(n):
         for j in range(i+1, n):
             d = np.linalg.norm(centers[i] - centers[j])
-            if d < 1e-8:
+            if d < 1e-7:
                 radii[i] *= 0.93
                 radii[j] *= 0.93
                 continue
             max_ij = d / 2.0
             if radii[i] > max_ij:
                 radii[i] = max_ij
             if radii[j] > max_ij:
                 radii[j] = max_ij
     return radii
+
+def centroidal_update(centers, radii, steps=2, rng=None):
+    """Move each center towards centroid of its local free space (gradient-free relaxation)."""
+    n = centers.shape[0]
+    newcenters = centers.copy()
+    gridres = 17
+    # For each circle, sample a grid around its position, weight by distance from other circles
+    for i in range(n):
+        x0, y0 = centers[i]
+        # Local grid window size
+        win = max(0.15, 2.2*radii[i])
+        xs = np.linspace(max(0.01, x0-win), min(0.99, x0+win), gridres)
+        ys = np.linspace(max(0.01, y0-win), min(0.99, y0+win), gridres)
+        grid = np.stack(np.meshgrid(xs, ys), -1).reshape(-1,2)
+        # Exclude points inside any other circle, or too near boundary
+        mask = np.ones(len(grid), dtype=bool)
+        for j in range(n):
+            if i==j: continue
+            d = np.linalg.norm(grid - centers[j], axis=1)
+            mask &= (d > radii[j]*1.08)
+        mask &= (grid[:,0]>radii[i]*1.01)
+        mask &= (grid[:,0]<1-radii[i]*1.01)
+        mask &= (grid[:,1]>radii[i]*1.01)
+        mask &= (grid[:,1]<1-radii[i]*1.01)
+        pts = grid[mask]
+        if len(pts)>0:
+            # Move toward centroid, but only a small step to avoid instability
+            centroid = np.mean(pts, axis=0)
+            delta = centroid - centers[i]
+            step = 0.25 * delta
+            # Optionally add a mild random kick
+            if rng is not None:
+                step += rng.normal(0, 0.001, 2)
+            newcenters[i] = centers[i] + step
+            newcenters[i] = np.clip(newcenters[i], 0.01, 0.99)
+        else:
+            # No space: small random move
+            if rng is not None:
+                newcenters[i] = centers[i] + rng.normal(0, 0.003, 2)
+                newcenters[i] = np.clip(newcenters[i], 0.01, 0.99)
+    return newcenters
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii