--- a/original.py
+++ b/original.py
@@ -1,108 +1,137 @@
 # EVOLVE-BLOCK-START
-"""Constructor-based circle packing for n=26 circles"""
+"""Hybrid density-based init + local optimization for n=26 circle packing"""
 
 import numpy as np
 
-
 def construct_packing():
     """
-    Construct a specific arrangement of 26 circles in a unit square
+    Construct a hybrid arrangement of 26 circles in a unit square
     that attempts to maximize the sum of their radii.
 
     Returns:
-        Tuple of (centers, radii, sum_of_radii)
+        Tuple of (centers, radii)
         centers: np.array of shape (26, 2) with (x, y) coordinates
         radii: np.array of shape (26) with radius of each circle
-        sum_of_radii: Sum of all radii
     """
-    # Initialize arrays for 26 circles
     n = 26
     centers = np.zeros((n, 2))
 
-    # Place circles in a structured pattern
-    # This is a simple pattern - evolution will improve this
+    # 1. Strategic placement: center, corners, edge-centers, and two staggered rings
+    idx = 0
+    # Center
+    centers[idx] = [0.5, 0.5]; idx += 1
+    # Corners
+    pad = 0.04
+    for x in [pad, 1-pad]:
+        for y in [pad, 1-pad]:
+            centers[idx] = [x, y]; idx += 1
+    # Edge centers
+    edge_pad = 0.04
+    for x, y in [(0.5, edge_pad), (0.5, 1-edge_pad), (edge_pad, 0.5), (1-edge_pad, 0.5)]:
+        centers[idx] = [x, y]; idx += 1
+    # First ring (8 points, radius ~0.28)
+    r1 = 0.28
+    for i in range(8):
+        angle = 2 * np.pi * i / 8
+        centers[idx] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]
+        idx += 1
+    # Second ring (8 points, radius ~0.62, offset for staggering)
+    r2 = 0.62
+    for i in range(8):
+        angle = 2 * np.pi * (i + 0.5) / 8
+        centers[idx] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]
+        idx += 1
+    assert idx == n
 
-    # First, place a large circle in the center
-    centers[0] = [0.5, 0.5]
+    # 2. Estimate local available space for each circle (nearest neighbor, border)
+    dists = np.full(n, np.inf)
+    for i in range(n):
+        # Distance to border
+        x, y = centers[i]
+        border_dist = min(x, y, 1-x, 1-y)
+        # Distance to nearest other center
+        for j in range(n):
+            if i == j: continue
+            d = np.linalg.norm(centers[i] - centers[j])
+            if d < dists[i]:
+                dists[i] = d
+        dists[i] = min(dists[i], 2*border_dist)
+    # Assign initial radii as a fraction of local available space
+    radii = 0.49 * dists
 
-    # Parameter sweep for inner and outer ring radii
-    best_sum = 0
-    best_centers = None
-    best_radii = None
-    # Systematic parameter sweep for both rings and corners
-    for ring1 in [0.26, 0.28, 0.30]:
-        for ring2 in [0.62, 0.65, 0.68]:
-            for corner_pad in [0.02, 0.03, 0.045]:
-                temp_centers = np.zeros((n, 2))
-                temp_centers[0] = [0.5, 0.5]
-                # 8 inner ring
-                for i in range(8):
-                    angle = 2 * np.pi * i / 8
-                    temp_centers[i + 1] = [0.5 + ring1 * np.cos(angle), 0.5 + ring1 * np.sin(angle)]
-                # 13 in outer ring (excluding corners)
-                for i in range(13):
-                    angle = 2 * np.pi * i / 13
-                    temp_centers[i + 9] = [0.5 + ring2 * np.cos(angle), 0.5 + ring2 * np.sin(angle)]
-                # Explicit corners
-                c = corner_pad
-                temp_centers[22] = [c, c]
-                temp_centers[23] = [1 - c, c]
-                temp_centers[24] = [c, 1 - c]
-                temp_centers[25] = [1 - c, 1 - c]
-                temp_centers = np.clip(temp_centers, 0.01, 0.99)
-                temp_radii = compute_max_radii(temp_centers)
-                sum_radii = np.sum(temp_radii)
-                if sum_radii > best_sum:
-                    best_sum = sum_radii
-                    best_centers = temp_centers
-                    best_radii = temp_radii
-    return best_centers, best_radii
+    # 3. Local greedy optimization: try to move circles to maximize their radii
+    np.random.seed(42)
+    for step in range(40):
+        order = np.random.permutation(n)
+        for i in order:
+            best_center = centers[i].copy()
+            best_radius = compute_one_max_radius(i, centers, radii)
+            # Try small moves in 8 directions
+            for dtheta in np.linspace(0, 2*np.pi, 8, endpoint=False):
+                delta = 0.015 * np.array([np.cos(dtheta), np.sin(dtheta)])
+                new_center = centers[i] + delta
+                # Stay inside square
+                if not (0.01 <= new_center[0] <= 0.99 and 0.01 <= new_center[1] <= 0.99):
+                    continue
+                centers[i] = new_center
+                r = compute_one_max_radius(i, centers, radii)
+                if r > best_radius:
+                    best_center = new_center.copy()
+                    best_radius = r
+            centers[i] = best_center
+            radii[i] = best_radius
 
+    # Final adjustment: ensure all radii are valid for the final config
+    radii = compute_max_radii(centers)
+    return centers, radii
+
+def compute_one_max_radius(i, centers, radii):
+    """Compute the largest possible radius for circle i given others and the square."""
+    x, y = centers[i]
+    # Border
+    r = min(x, y, 1-x, 1-y)
+    # Other circles
+    for j in range(centers.shape[0]):
+        if i == j:
+            continue
+        d = np.linalg.norm(centers[i] - centers[j])
+        r = min(r, d - radii[j] if d > radii[j] else 0)
+    return max(r, 0.0)
 
 def compute_max_radii(centers):
     """
     Compute the maximum possible radii for each circle position
     such that they don't overlap and stay within the unit square.
 
     Args:
         centers: np.array of shape (n, 2) with (x, y) coordinates
 
     Returns:
         np.array of shape (n) with radius of each circle
     """
     n = centers.shape[0]
     radii = np.ones(n)
-
-    # First, limit by distance to square borders
+    # Limit by distance to square borders
     for i in range(n):
         x, y = centers[i]
-        # Distance to borders
-        radii[i] = min(x, y, 1 - x, 1 - y)
-
-    # Then, limit by distance to other circles
-    # Each pair of circles with centers at distance d can have
-    # sum of radii at most d to avoid overlap
+        radii[i] = min(x, y, 1-x, 1-y)
+    # Limit by distance to other circles
     for i in range(n):
-        for j in range(i + 1, n):
-            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))
-
-            # If current radii would cause overlap
+        for j in range(i+1, n):
+            dist = np.linalg.norm(centers[i] - centers[j])
             if radii[i] + radii[j] > dist:
-                # Scale both radii proportionally
                 scale = dist / (radii[i] + radii[j])
                 radii[i] *= scale
                 radii[j] *= scale
-
     return radii
-
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii