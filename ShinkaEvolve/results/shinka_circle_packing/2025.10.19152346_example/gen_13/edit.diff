--- a/original.py
+++ b/original.py
@@ -1,151 +1,143 @@
 # EVOLVE-BLOCK-START
-"""Adaptive edge-center hybrid circle packing for n=26 circles"""
+# EVOLVE-BLOCK-START
+"""Hybrid structured and adaptive circle packing for n=26 circles"""
 
 import numpy as np
 
 def construct_packing():
     """
-    Construct an adaptive arrangement of 26 circles in a unit square
-    that attempts to maximize the sum of their radii.
+    Construct a hybrid arrangement of 26 circles in a unit square,
+    combining structured placement with adaptive refinement.
     Returns:
         Tuple of (centers, radii)
         centers: np.array of shape (26, 2) with (x, y) coordinates
         radii: np.array of shape (26) with radius of each circle
     """
     n = 26
     centers = np.zeros((n, 2))
     radii = np.zeros(n)
 
-    # Parameters
-    edge_weight = 8
-    corner_weight = 4
-    center_weight = 6
-    inner_ring_weight = 8
-    perturb_scale = 0.012
-    adaptive_iters = 18
-    shrink_factor = 0.98
+    # 1. Place 4 corner circles with small offsets
+    corner_offsets = 0.01
+    centers[0] = [corner_offsets, corner_offsets]
+    centers[1] = [1 - corner_offsets, corner_offsets]
+    centers[2] = [1 - corner_offsets, 1 - corner_offsets]
+    centers[3] = [corner_offsets, 1 - corner_offsets]
+    for i in range(4):
+        radii[i] = 0.02
 
-    # 1. Place 4 large circles near corners
-    corner_pos = [
-        [0.08, 0.08],
-        [0.92, 0.08],
-        [0.92, 0.92],
-        [0.08, 0.92]
+    # 2. Place 8 edge-centered circles
+    edge_positions = [
+        [0.5, corner_offsets],
+        [1 - corner_offsets, 0.5],
+        [0.5, 1 - corner_offsets],
+        [corner_offsets, 0.5],
+        [0.25, corner_offsets],
+        [0.75, corner_offsets],
+        [1 - corner_offsets, 0.25],
+        [1 - corner_offsets, 0.75],
+        [corner_offsets, 0.25],
+        [corner_offsets, 0.75],
+        [0.25, 1 - corner_offsets],
+        [0.75, 1 - corner_offsets]
     ]
-    for i in range(corner_weight):
-        centers[i] = corner_pos[i]
-        radii[i] = 0.08
+    for i, pos in enumerate(edge_positions, start=4):
+        centers[i] = pos
+        radii[i] = 0.02
 
-    # 2. Place 8 circles along edges (not at corners)
-    edge_offsets = np.linspace(0.22, 0.78, edge_weight//2)
-    idx = corner_weight
-    for x in edge_offsets:
-        centers[idx] = [x, 0.04]
-        centers[idx+1] = [x, 0.96]
-        radii[idx] = radii[idx+1] = 0.06
-        idx += 2
+    # 3. Place center circle
+    centers[16] = [0.5, 0.5]
+    radii[16] = 0.05
 
-    # 3. Place 6 circles in the center region (hex pattern)
-    center_hex = [
-        [0.5, 0.5],
-        [0.5+0.13, 0.5],
-        [0.5-0.13, 0.5],
-        [0.5, 0.5+0.13],
-        [0.5, 0.5-0.13],
-        [0.5+0.09, 0.5+0.09]
-    ]
-    for i in range(center_weight):
-        centers[idx] = center_hex[i]
-        radii[idx] = 0.10
-        idx += 1
+    # 4. Place 4 inner ring circles around center
+    for i in range(4):
+        angle = 2 * np.pi * i / 4 + np.pi/4
+        centers[17 + i] = [0.5 + 0.15 * np.cos(angle), 0.5 + 0.15 * np.sin(angle)]
+        radii[17 + i] = 0.04
 
-    # 4. Place 8 circles in an inner ring
-    ring_r = 0.28
-    for i in range(inner_ring_weight):
-        angle = 2 * np.pi * i / inner_ring_weight
-        centers[idx] = [0.5 + ring_r * np.cos(angle), 0.5 + ring_r * np.sin(angle)]
-        radii[idx] = 0.07
-        idx += 1
+    # 5. Place 4 more in a larger ring
+    for i in range(4):
+        angle = 2 * np.pi * i / 4
+        centers[21 + i] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]
+        radii[21 + i] = 0.03
 
-    # 5. Small random perturbations to break symmetry
-    centers += np.random.uniform(-perturb_scale, perturb_scale, centers.shape)
+    # 6. Perturb initial positions slightly
+    centers += np.random.uniform(-0.005, 0.005, centers.shape)
     centers = np.clip(centers, 0.01, 0.99)
 
-    # 6. Adaptive local optimization
-    for it in range(adaptive_iters):
-        # Recompute radii to maximize size without overlap or boundary violation
+    # 7. Adaptive refinement loop
+    adaptive_iters = 20
+    for _ in range(adaptive_iters):
         radii = compute_max_radii(centers)
-        # Nudge centers away from overlaps and boundaries
+        # Boundary and overlap adjustments
         for i in range(n):
             grad = np.zeros(2)
             # Boundary repulsion
             for d in range(2):
-                if centers[i, d] - radii[i] < 0.0:
+                if centers[i, d] - radii[i] < 0.01:
                     grad[d] += (0.01 - (centers[i, d] - radii[i])) * 0.5
-                if centers[i, d] + radii[i] > 1.0:
+                if centers[i, d] + radii[i] > 0.99:
                     grad[d] -= ((centers[i, d] + radii[i]) - 0.99) * 0.5
             # Overlap repulsion
             for j in range(n):
                 if i == j:
                     continue
                 dist = np.linalg.norm(centers[i] - centers[j])
                 min_dist = radii[i] + radii[j]
                 if dist < min_dist - 1e-6:
                     if dist > 1e-8:
-                        grad += (centers[i] - centers[j]) / dist * (min_dist - dist) * 0.15
+                        grad += (centers[i] - centers[j]) / dist * (min_dist - dist) * 0.2
                     else:
                         grad += np.random.uniform(-1, 1, 2) * 0.01
-            # Apply small step
-            centers[i] += grad * 0.25
-        # Clip to square
+            centers[i] += grad * 0.2
         centers = np.clip(centers, 0.01, 0.99)
-        # If overlaps persist, shrink radii slightly
+        # Shrink radii if overlaps persist
         for i in range(n):
             for j in range(i+1, n):
                 dist = np.linalg.norm(centers[i] - centers[j])
                 if dist < radii[i] + radii[j] - 1e-6:
-                    radii[i] *= shrink_factor
-                    radii[j] *= shrink_factor
+                    radii[i] *= 0.98
+                    radii[j] *= 0.98
 
-    # Final radii computation
+    # Final radii calculation
     radii = compute_max_radii(centers)
     return centers, radii
 
 def compute_max_radii(centers):
     """
-    Compute the maximum possible radii for each circle position
-    such that they don't overlap and stay within the unit square.
-    Args:
-        centers: np.array of shape (n, 2) with (x, y) coordinates
-    Returns:
-        np.array of shape (n) with radius of each circle
+    Compute maximum radii for each circle based on boundary and neighbor constraints.
     """
     n = centers.shape[0]
     radii = np.ones(n)
-    # Limit by distance to square borders
+    # Boundary constraints
     for i in range(n):
         x, y = centers[i]
         radii[i] = min(x, y, 1 - x, 1 - y)
-    # Limit by distance to other circles
+    # Overlap constraints
     for i in range(n):
         for j in range(i + 1, n):
             dist = np.linalg.norm(centers[i] - centers[j])
-            if dist < 1e-8:
-                continue
-            max_r = dist / 2.0
-            if radii[i] > max_r:
-                radii[i] = max_r
-            if radii[j] > max_r:
-                radii[j] = max_r
+            if dist > 1e-8:
+                max_r = dist / 2
+                if radii[i] > max_r:
+                    radii[i] = max_r
+                if radii[j] > max_r:
+                    radii[j] = max_r
     return radii
 
+# This part remains fixed
+def run_packing():
+    """Run the circle packing constructor for n=26"""
+    centers, radii = construct_packing()
+    sum_radii = np.sum(radii)
+    return centers, radii, sum_radii
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii
