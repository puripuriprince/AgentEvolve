--- a/original.py
+++ b/original.py
@@ -1,174 +1,97 @@
 # EVOLVE-BLOCK-START
-"""Adaptive edge-center hybrid circle packing for n=26 circles"""
+"""Simulated annealing-based circle packing for n=26 circles"""
 
 import numpy as np
 
 def construct_packing():
     """
-    Construct an adaptive arrangement of 26 circles in a unit square
-    that attempts to maximize the sum of their radii.
+    Simulated annealing-based arrangement of 26 circles in a unit square.
     Returns:
-        Tuple of (centers, radii)
-        centers: np.array of shape (26, 2) with (x, y) coordinates
-        radii: np.array of shape (26) with radius of each circle
+        centers: np.array of shape (26,2)
+        radii:   np.array of shape (26,)
     """
     n = 26
-    centers = np.zeros((n, 2))
-    radii = np.zeros(n)
+    # 1) Initialize centers randomly in [0.1,0.9]^2
+    centers = np.random.rand(n,2) * 0.8 + 0.1
+    radii = compute_max_radii(centers)
+    current_sum = np.sum(radii)
 
-    # Parameters
-    edge_weight = 8
-    corner_weight = 4
-    center_weight = 6
-    inner_ring_weight = 8
-    perturb_scale = 0.012
-    adaptive_iters = 18
-    shrink_factor = 0.98
+    # 2) Simulated annealing parameters
+    max_iter = 10000
+    step_start = 0.1
+    step_end   = 0.005
 
-    # 1. Place 4 large circles near corners
-    corner_pos = [
-        [0.08, 0.08],
-        [0.92, 0.08],
-        [0.92, 0.92],
-        [0.08, 0.92]
-    ]
-    for i in range(corner_weight):
-        centers[i] = corner_pos[i]
-        radii[i] = 0.08
+    for k in range(max_iter):
+        t = k / (max_iter - 1)
+        step = step_start*(1 - t) + step_end*t
+        T = step  # temperature
 
-    # 2. Place 8 circles along edges (not at corners)
-    edge_offsets = np.linspace(0.22, 0.78, edge_weight//2)
-    idx = corner_weight
-    for x in edge_offsets:
-        centers[idx] = [x, 0.04]
-        centers[idx+1] = [x, 0.96]
-        radii[idx] = radii[idx+1] = 0.06
-        idx += 2
+        # pick one circle to move
+        i = np.random.randint(n)
+        cand = centers.copy()
+        cand[i] += np.random.randn(2) * step
+        cand[i] = np.clip(cand[i], 0.0, 1.0)
 
-    # 3. Place 6 circles in the center region (hex pattern)
-    center_hex = [
-        [0.5, 0.5],
-        [0.5+0.14, 0.5],
-        [0.5-0.14, 0.5],
-        [0.5, 0.5+0.14],
-        [0.5, 0.5-0.14],
-        [0.5+0.095, 0.5+0.095]
-    ]
-    for i in range(center_weight):
-        centers[idx] = center_hex[i]
-        radii[idx] = 0.10
-        idx += 1
+        # recompute radii and objective
+        rad_cand = compute_max_radii(cand)
+        sum_cand = np.sum(rad_cand)
 
-    # 4. Place 8 circles in an inner ring
-    ring_r = 0.33
-    for i in range(inner_ring_weight):
-        angle = 2 * np.pi * i / inner_ring_weight
-        centers[idx] = [0.5 + ring_r * np.cos(angle), 0.5 + ring_r * np.sin(angle)]
-        radii[idx] = 0.07
-        idx += 1
+        # acceptance
+        Δ = sum_cand - current_sum
+        if Δ >= 0 or np.random.rand() < np.exp(Δ / T):
+            centers = cand
+            radii = rad_cand
+            current_sum = sum_cand
 
-    # Compute adaptive initial radii based on spacing
-    initial_shrink = 0.9
-    radii = compute_max_radii(centers) * initial_shrink
+    # 3) Final local refinement (greedy)
+    refine_iters = 2000
+    for _ in range(refine_iters):
+        i = np.random.randint(n)
+        cand = centers.copy()
+        cand[i] += np.random.randn(2) * step_end
+        cand[i] = np.clip(cand[i], 0.0, 1.0)
+        rad_cand = compute_max_radii(cand)
+        sum_cand = np.sum(rad_cand)
+        if sum_cand > current_sum:
+            centers = cand
+            radii = rad_cand
+            current_sum = sum_cand
 
-    # 5. Small random perturbations to break symmetry
-    centers += np.random.uniform(-perturb_scale, perturb_scale, centers.shape)
-    centers = np.clip(centers, 0.01, 0.99)
-
-    # 6. Adaptive local optimization
-    prev_sum = 0.0
-    for it in range(adaptive_iters):
-        # Recompute radii to maximize size without overlap or boundary violation
-        radii = compute_max_radii(centers)
-        curr_sum = np.sum(radii)
-
-        # Early stopping if improvement is negligible
-        if abs(curr_sum - prev_sum) < 1e-5:
-            break
-        prev_sum = curr_sum
-
-        # Calculate total overlap to consider early stopping
-        total_overlap = 0.0
-        for i in range(n):
-            for j in range(i+1, n):
-                dist = np.linalg.norm(centers[i] - centers[j])
-                overlap = max(0.0, radii[i] + radii[j] - dist)
-                total_overlap += overlap
-        if total_overlap < 1e-4:
-            break
-
-        # Nudge centers away from overlaps and boundaries
-        overlaps_per_circle = np.zeros(n)
-        for i in range(n):
-            grad = np.zeros(2)
-            # Boundary repulsion
-            for d in range(2):
-                if centers[i, d] - radii[i] < 0.0:
-                    grad[d] += (0.01 - (centers[i, d] - radii[i])) * 0.5
-                if centers[i, d] + radii[i] > 1.0:
-                    grad[d] -= ((centers[i, d] + radii[i]) - 0.99) * 0.5
-            # Overlap repulsion
-            for j in range(n):
-                if i == j:
-                    continue
-                dist = np.linalg.norm(centers[i] - centers[j])
-                min_dist = radii[i] + radii[j]
-                if dist < min_dist - 1e-6:
-                    overlaps_per_circle[i] += 1
-                    if dist > 1e-8:
-                        grad += (centers[i] - centers[j]) / dist * (min_dist - dist) * 0.15
-                    else:
-                        grad += np.random.uniform(-1, 1, 2) * 0.01
-            # Apply small step
-            centers[i] += grad * 0.25
-        # Clip to square
-        centers = np.clip(centers, 0.01, 0.99)
-
-        # Adaptive per-circle shrink factor based on overlaps count
-        for i in range(n):
-            if overlaps_per_circle[i] > 0:
-                factor = shrink_factor ** overlaps_per_circle[i]
-                radii[i] *= factor
-
-    # Final radii computation
+    # final radii
     radii = compute_max_radii(centers)
     return centers, radii
 
 def compute_max_radii(centers):
     """
-    Compute the maximum possible radii for each circle position
-    such that they don't overlap and stay within the unit square.
-    Args:
-        centers: np.array of shape (n, 2) with (x, y) coordinates
-    Returns:
-        np.array of shape (n) with radius of each circle
+    Given circle centers, compute the maximum non-overlapping radii
+    that keep all circles inside the unit square.
     """
     n = centers.shape[0]
-    radii = np.ones(n)
-    # Limit by distance to square borders
+    radii = np.zeros(n)
+    # boundary-limited radii
     for i in range(n):
-        x, y = centers[i]
-        radii[i] = min(x, y, 1 - x, 1 - y)
-    # Limit by distance to other circles
+        x,y = centers[i]
+        radii[i] = min(x, y, 1-x, 1-y)
+
+    # pairwise overlap constraints
     for i in range(n):
-        for j in range(i + 1, n):
-            dist = np.linalg.norm(centers[i] - centers[j])
-            if dist < 1e-8:
+        for j in range(i+1, n):
+            d = np.linalg.norm(centers[i] - centers[j])
+            if d <= 0: 
                 continue
-            max_r = dist / 2.0
-            if radii[i] > max_r:
-                radii[i] = max_r
-            if radii[j] > max_r:
-                radii[j] = max_r
+            # if sum of current radii > d, scale both
+            if radii[i] + radii[j] > d:
+                scale = d / (radii[i] + radii[j])
+                radii[i] *= scale
+                radii[j] *= scale
     return radii
-
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii