<NAME>iterative_pairwise_refinement</NAME>
<DESCRIPTION>
Enhance compute_max_radii by performing multiple refinement passes over circle pairs. Precompute sorted pairs by center distance to apply overlap corrections in order of proximity, and iterate several times (max_iter=10) to achieve tighter packings and larger radii sum.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
def compute_max_radii(centers):
    """
    Compute the maximum possible radii for each circle position
    such that they don't overlap and stay within the unit square.

    Args:
        centers: np.array of shape (n, 2) with (x, y) coordinates

    Returns:
        np.array of shape (n) with radius of each circle
    """
    n = centers.shape[0]
    radii = np.ones(n)

    # First, limit by distance to square borders
    for i in range(n):
        x, y = centers[i]
        # Distance to borders
        radii[i] = min(x, y, 1 - x, 1 - y)

    # Then, limit by distance to other circles
    # Each pair of circles with centers at distance d can have
    # sum of radii at most d to avoid overlap
    for i in range(n):
        for j in range(i + 1, n):
            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))

            # If current radii would cause overlap
            if radii[i] + radii[j] > dist:
                # Scale both radii proportionally
                scale = dist / (radii[i] + radii[j])
                radii[i] *= scale
                radii[j] *= scale

    return radii
=======
def compute_max_radii(centers):
    """
    Compute the maximum possible radii for each circle position
    such that they don't overlap and stay within the unit square.
    Uses iterative refinement over sorted circle pairs for tighter packings.
    """
    n = centers.shape[0]
    radii = np.ones(n)

    # 1) Limit by distance to square borders
    for i in range(n):
        x, y = centers[i]
        radii[i] = min(x, y, 1 - x, 1 - y)

    # 2) Precompute all circle pairs with their center distances
    pairs = []
    for i in range(n):
        for j in range(i + 1, n):
            d = np.hypot(*(centers[i] - centers[j]))
            pairs.append((d, i, j))
    # Sort by proximity: closest circles first
    pairs.sort(key=lambda t: t[0])

    # 3) Iteratively refine radii to resolve overlaps
    max_iter = 10
    for _ in range(max_iter):
        for d, i, j in pairs:
            if radii[i] + radii[j] > d:
                scale = d / (radii[i] + radii[j])
                radii[i] *= scale
                radii[j] *= scale

    return radii
>>>>>>> REPLACE
</DIFF>

<NAME>rng_initialization</NAME>
<DESCRIPTION>
Introduce a fixed random number generator at the start of construct_packing to enable controlled jitter in circle placements, breaking perfect symmetry and potentially improving local fit.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    centers = np.zeros((n, 2))
=======
    centers = np.zeros((n, 2))
    rng = np.random.RandomState(42)
>>>>>>> REPLACE
</DIFF>

<NAME>ring1_jitter</NAME>
<DESCRIPTION>
Apply slight random perturbations to the inner ring radius distance to break symmetry and potentially improve packing by offsetting perfect regularity.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Place 8 circles around the center
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.4  # distance from center for outer ring
        centers[i + 1] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
=======
    # Place 8 circles around the center with slight random jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.4 + rng.uniform(-0.01, 0.01)  # perturbed distance to break symmetry
        centers[i + 1] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
>>>>>>> REPLACE
</DIFF>

<NAME>ring2_jitter</NAME>
<DESCRIPTION>
Add small random variations to the middle ring placement radius to further disrupt uniform spacing and aid tighter local configurations.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Place 8 more circles in an outer ring
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.6  # further out
        centers[i + 9] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
=======
    # Place 8 more circles in a middle ring with jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.6 + rng.uniform(-0.015, 0.015)
        centers[i + 9] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
>>>>>>> REPLACE
</DIFF>

<NAME>ring3_jitter</NAME>
<DESCRIPTION>
Introduce random jitter in the outermost ring radius to avoid overly regular layouts and potentially allow larger overall radii after refinement.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Place 8 smallest circles at the outermost positions
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.8
        centers[i + 17] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
=======
    # Place 8 smallest circles at the outermost ring with jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.8 + rng.uniform(-0.02, 0.02)
        centers[i + 17] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]
>>>>>>> REPLACE
</DIFF>