<NAME>
triple_ring_sweep
</NAME>

<DESCRIPTION>
Replace the random jitter placement of the three concentric rings with a systematic parameter sweep over candidate radii for the inner, middle, and outer rings. For each combination of ring distances, we build the configuration, compute maximal radii, and track the best sum. This structured exploration is likely to find better circle placements than the previous unstructured jitter.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Place 8 circles around the center with slight jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.4 + rng.uniform(-0.01, 0.01)  # perturbed distance for jitter
        centers[i + 1] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]

    # Place 8 more circles in an outer ring with slight jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.6 + rng.uniform(-0.015, 0.015)  # perturbed distance for jitter
        centers[i + 9] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]

    # Place 8 smallest circles at the outermost positions with slight jitter
    for i in range(8):
        angle = 2 * np.pi * i / 8
        radius_dist = 0.8 + rng.uniform(-0.02, 0.02)  # perturbed distance for jitter
        centers[i + 17] = [0.5 + radius_dist * np.cos(angle), 0.5 + radius_dist * np.sin(angle)]

    # Additional positioning adjustment to make sure all circles
    # are inside the square and don't overlap
    # Clip to ensure everything is inside the unit square
    centers = np.clip(centers, 0.01, 0.99)
=======
    # Parameter sweep for three concentric rings
    best_sum = 0.0
    best_centers = None
    for ring1 in [0.38, 0.40, 0.42]:
        for ring2 in [0.58, 0.60, 0.62]:
            for ring3 in [0.78, 0.80, 0.82]:
                temp_centers = np.zeros((n, 2))
                temp_centers[0] = [0.5, 0.5]
                # inner ring
                for i in range(8):
                    a = 2 * np.pi * i / 8
                    temp_centers[i + 1] = [0.5 + ring1 * np.cos(a), 0.5 + ring1 * np.sin(a)]
                # middle ring with offset
                for i in range(8):
                    a = 2 * np.pi * i / 8 + np.pi / 8
                    temp_centers[i + 9] = [0.5 + ring2 * np.cos(a), 0.5 + ring2 * np.sin(a)]
                # outer ring with another offset
                for i in range(8):
                    a = 2 * np.pi * i / 8 + np.pi / 4
                    temp_centers[i + 17] = [0.5 + ring3 * np.cos(a), 0.5 + ring3 * np.sin(a)]
                temp_centers = np.clip(temp_centers, 0.01, 0.99)
                temp_radii = compute_max_radii(temp_centers)
                s = np.sum(temp_radii)
                if s > best_sum:
                    best_sum = s
                    best_centers = temp_centers
    # Adopt the best configuration found
    centers = best_centers
    # Ensure still within unit square
    centers = np.clip(centers, 0.01, 0.99)
>>>>>>> REPLACE
</DIFF>